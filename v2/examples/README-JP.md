This doc in English: [go/om2-example](http://goto.google.com/om2-example)  
GitHubレポ [https://github.com/googleforgames/open-match-ecosystem/tree/main/v2](https://github.com/googleforgames/open-match-ecosystem/tree/main/v2)

### **Open Match 2 サンプルマッチメーカーのアーキテクチャ概要**

v2/ディレクトリにあるサンプルマッチメーカーは、Open Match 2を使用して完全なマッチメイキングシステムを構築する方法を示します。ローカル開発用のモノリシックなデプロイメントと、本番環境で推奨される分離されたマイクロサービスベースのアーキテクチャの両方をサポートするように、柔軟に設計されています。

#### **コアコンポーネントとワークフロー**

このシステムは主にexamples/ディレクトリにある3つのアプリケーションで構成されており、これらはinternal/ディレクトリの共有ロジックを活用しています。

**1\. アプリケーション (**examples/**ディレクトリ):**

* **matchmaker**: すべてのコンポーネントを単一のプロセスで実行する開発およびテスト用のハーネスです。メモリ内のmmqueue、gsdirector、およびローカルのマッチメイキング機能（MMF）サーバーを初期化するため、複数のサービスをデプロイすることなくローカル開発を行うのに理想的です。  
* **standalone/mmqueue (マッチメイキングキュー):** ゲームクライアント向けのフロントエンドサービスです。  
  * **機能:** クライアントからのマッチメイキングリクエストを受け取り、Open MatchのTicket protobufを作成し、omclientを介してom-coreでの作成と有効化のためにキューに入れます。また、Directorから最終的なゲームサーバーのアサインメントを受け取り、クライアントに返します。  
* **standalone/gsdirector (ゲームサーバーDirector):** ゲームサーバーマネージャーとのマッチメイキングプロセスを調整するバックエンドサービスです。  
  * **機能:** ゲームサーバーマネージャー（この例ではモックのAgonesインテグレーション）にクエリを送信し、どのような種類のマッチが必要かを判断します。次にProfileオブジェクトを構築し、om-coreのInvokeMatchmakingFunctionsエンドポイントを呼び出します。Matchの提案を受け取った後、それらを評価し、承認されたマッチにゲームサーバーを割り当て、接続詳細をmmqueueに送信します。  
* **mmf (マッチメイキング機能):** カスタムのゲーム固有のマッチングロジックを含む、スタンドアロンのgRPCサーバーです。  
  * **機能:** om-coreはこのサービスのRunメソッドを呼び出し、フィルタリングされたチケットのプールを含むProfileをストリーミングします。MMFは自身のロジック（例：提供されているfifo関数は単純な先入れ先出しのマッチを作成）を実行し、Matchの提案をストリームで返します。

**2\. 共有ロジック (**internal/**ディレクトリ):**

* **omclient**: om-coreサービスのgRPC-Gatewayエンドポイントと通信するためのRESTful HTTPクライアント。チケットの作成、有効化、マッチメイキング機能の呼び出しを処理します。  
* **mmqueue**: マッチメイキングキューのコアロジックを含むモジュール。クライアントリクエストの管理やGoチャネルを介したアサインメントの処理が含まれます。モノリシックなmatchmakerの一部として、またはスタンドアロンのmmqueueサービスとして実行できます。  
* **gsdirector**: ゲームサーバーDirectorのロジックを含みます。このモジュールにはMockAgonesIntegrationが含まれており、これは特定のリージョンで利用可能なゲームモードなどのマッチメイキング要件を提供し、モックのサーバー割り当てを処理することで、ゲームサーバーマネージャーをシミュレートします。  
* **assignmentdistributor**: : サンプルがゲームサーバーDirectorからマッチメイキングキューにアサインメントを返すために使用するインターフェース、および2つの実装（1つはGoogle Cloud Pub/Subを使用、もう1つはローカル開発用にgolangチャネルを使用）。 
* **metrics & logging**: すべてのアプリケーションで使用される、OpenTelemetryメトリクスと構造化されたLogrusロギングを初期化するための中央集権的なモジュールです。  
* **extensions**: Open Matchのprotobufメッセージで広く使用されるgoogle.protobuf.Any型を扱うためのユーティリティ関数を提供します。  
* **mocks/gameclient**: テスト目的でゲームクライアントからのリクエストをシミュレートする、モックのTicketオブジェクトを生成するユーティリティです。

### **マッチメーカーの設計解説**

Open Match v2サンプルマッチメーカーの設計は、3つの主要な情報を調整（リコンサイル）することを中心に展開されます。それは、特定のゲームモードに対して**プレイヤーをどのようにマッチングさせるか**のルール、**利用可能なゲームサーバー**のインベントリとそれらがホストできるマッチの種類、そしてマッチを待っている**利用可能なプレイヤー**のプールです。

#### **単一の信頼できる情報源（Single Source of Truth）としてのゲームサーバー（サーバーの可用性とマッチロジック）**

本番環境では、サーバーの可用性に関する情報とマッチ作成のルールは連携しており、ゲームサーバー自体が単一の信頼できる情報源として機能します。

* **推奨される本番設計**: GameMode（マッチメイキングルール、プレイヤーのプール、MMFパラメータを含む）の定義は、マッチメーカーにハードコードするのではなく、TerraformやHelmのようなInfrastructure-as-Code（IaC）ツールを通じて管理されます。デプロイ時に、これらのGameMode仕様はAgones Fleetなどのゲームサーバーテンプレートにメタデータ（例：Kubernetesアノテーション）として適用されます。その結果、そのFleetから作成されたすべてのGameServerインスタンスは、ホストするように設計されたマッチの正確な定義を自動的に継承します。  
* **サンプルでのシミュレーション方法**: サンプルマッチメーカーは、v2/internal/gsdirector/gsdirector.go内のMockAgonesIntegrationを使用してこの本番設計をシミュレートします。  
  * 静的なGameMode、FleetConfig、zonePools変数は、IaCツールに存在するであろう設定の代役です。  
  * MockAgonesIntegration.Init()関数はデプロイプロセスをシミュレートし、これらの静的設定を消費してメモリ内にgameServersのマップを生成します。このマップ内の各モックサーバーは、それが必要とする特定のMmfRequestに関連付けられます。  
  * 次に、DirectorはGetMMFParams()を呼び出します。実際のシステムでは、この関数はKubernetes APIにクエリを送信して準備完了状態のGameServerを検出し、そのマッチメイキングメタデータを直接読み取ります。このサンプルでは、初期化時に作成されたメモリ内のマップから単純に読み取るだけです。  
* このアプローチにより、Directorは常にゲームサーバーインフラの最新の状態に基づいて動作し、別途設定を必要とせずに、どのような種類のマッチが必要かを自動的に検出できます。

#### **利用可能なプレイヤー情報の保存**

この責務は、マッチメイキングキューとOpen Match Coreの連携によって担われます。

* **マッチメイキングキュー (mmqueue)**: このサービス (v2/internal/mmqueue/mmqueue.go) はプレイヤーにとっての入り口です。プレイヤーからのマッチ検索リクエストを受け付け、Open MatchのTicketオブジェクトを作成します。  
* **Open Match Core (om-core)**: om-coreは権威あるステートストアです。mmqueueはom-core内でチケットを作成・有効化し、om-coreは現在マッチを待っているすべてのプレイヤーのクエリ可能な確定的なプールを維持します。

### **リコンシリエーション（調整）プロセス**

システムの主要な機能は、まずサーバーの可用性とそれがホストできるゲームモードのルールを調整し、どのようなプレイヤーが必要かを理解することです。次に、そのニーズを利用可能なプレイヤーのプールと照合して最適なマッチを作成し、適切なサーバーに割り当てます。

#### **サーバーニーズの調整**

* **担当コンポーネント**: ゲームサーバーDirector **(gsdirector)**。  
* **プロセス**: gsdirectorのメインループは、ゲームサーバーマネージャー（MockAgonesIntegration.GetMMFParams()によってシミュレート）にクエリを送信することから始まります。これにより、利用可能なゲームサーバーのメタデータから直接MmfRequestオブジェクトが検出されます。この最初のステップで、サーバーの可用性とマッチ要件が調整され、実行すべき具体的なマッチメイキングタスクのリストが生成されます。

#### **プレイヤーとサーバーニーズの調整**

* **担当コンポーネント**: **gsdirector**、**om-core**、および**mmf**の連携。  
* **プロセス**:  
  * gsdirectorは検出したMmfRequestをom-coreに送信します。  
  * om-coreは、各リクエストのPools内の基準に基づいて、利用可能なプレイヤーのデータベースをフィルタリングします。  
  * 次に、om-coreは適切な\*\*マッチメイキング機能 (mmf)\*\*を呼び出し、フィルタリングされたプレイヤーのプールをストリーミングします。  
  * mmfはゲーム固有のロジックを実行し、Matchの提案をストリームで返します。  
  * 最後に、gsdirectorはこれらの提案を受け取り、最終検証を行い、承認された各マッチに特定の準備完了状態のゲームサーバーを割り当て、プレイヤーからサーバーへのアサインメントを完了させます。

### **高度なマッチメーカー操作：バックフィルとチケット衝突の処理**

主要なマッチメイキングフローに加えて、堅牢なシステムは、部分的に空のゲームサーバーを埋める（バックフィル）や、同じプレイヤーが同時に複数のマッチに提案されるケースを解決する（チケット衝突）といった一般的なシナリオを処理する必要があります。

#### **バックフィルの処理**

サンプルマッチメーカーは、バックフィルを、MMFが満員でないマッチを作成した際に生成される、特定の高優先度のマッチメイキングリクエストとして扱います。

* **バックフィルリクエストの生成 (MMF内)**:  
  * プロセスはv2/examples/mmf/functions/fifo/fifo.goなどのMMFで始まります。MMFがマッチを形成するものの、利用可能なチケットプールから全てのプレイヤースロットを埋めることができない場合、そのマッチを不完全と判断します。  
  * om-coreにマッチ提案を返す前に、MMFは*新しい*MmfRequestを構築します。この新しいリクエストには、空のスロットを埋めるために必要な特定のタイプと数のプレイヤーを見つけるために調整された新しいProfileが含まれています。  
  * この新しいバックフィルMmfRequestは、元のMatch提案のextensionsフィールドに添付されます。  
* **バックフィルリクエストの処理 (Director内)**:  
  * gsdirectorはMMFからマッチ提案を受け取り、そのextensionsを検査します。添付されたバックフィルリクエストを見つけた場合、このマッチをホストするゲームサーバーが後でさらにプレイヤーを必要とすることを知ります。  
  * 次に、Directorはゲームサーバーマネージャー（MockAgonesIntegration）のUpdateMMFRequestを呼び出します。この関数は、割り当てられたゲームサーバーのメタデータを更新し、新しいバックフィル要件を反映させます。これにより、次のマッチメイキングサイクルで、この特定のサーバーが新しいユニークなマッチメイキングリクエストの源となります。  
  * **優先順位付け**: Directorはこれらの特定のバックフィルリクエストを本質的に優先します。GetMMFParams関数がゲームサーバーからすべてのマッチメイキングリクエストを収集する際、同じリクエストを共有するサーバーの数に基づいてソートします。バックフィルリクエストは単一のサーバーに固有であるため、参照カウントが最も低くなり、リストの先頭に配置されます。これにより、バックフィルリクエストが最初にom-coreに送信され、迅速に処理される可能性が高まります。

#### **チケット衝突の処理**

Open Match 2は複数のMMFを並行して実行できるため、同じTicketが同一サイクル内で複数のMatch提案に含まれる可能性があります。これらの「チケット衝突」を検出し解決する責任は、完全にDirectorにあります。

* **衝突の検出**:  
  * gsdirectorはassignmentsマップを維持しており、これは現在のセッションで正常にゲームサーバーに割り当てられたすべてのチケットIDの記録として機能します。  
  * MMFからマッチ提案のストリームを受け取り、サーバーを割り当てる前に、Directorは各提案マッチを反復処理します。そのマッチ内のすべてのチケットについて、そのチケットIDがassignmentsマップに既に存在するかどうかを確認します。  
* **衝突の解決**:  
  * Directorが提案されたマッチ内に既に割り当て済みのチケットを見つけた場合、これを衝突とみなします。  
  * 衝突するチケットを含むマッチ提案全体は、直ちに**拒否**されます。  
  * 拒否されたマッチのすべてのチケットは、ActivateTickets APIを介して再有効化のためにom-coreに送り返されます。これにより、（既に割り当てられたプレイヤーを除く）それらのプレイヤーは次のマッチメイキングサイクルで再び利用可能になります。この単純な「先着順」アプローチにより、一度プレイヤーが割り当てられると、別のマッチに配置されることはありません。

